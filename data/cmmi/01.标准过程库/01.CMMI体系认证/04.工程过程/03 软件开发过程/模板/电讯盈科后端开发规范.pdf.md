电讯盈科后端开发规范​
电讯盈科​
开发规范​
版本：V1.0​
日期：2023-01-06​
修订记录
文档版本号​
修订日期​
修订内容简述​
编制人​
审批人​
V1.0​
2023/01/06​
起草，修订​
寇文君​
石荣磊​
第一章：开发规范
1. 代码规范​
1.1 Java代码规范​
Java编码规范直接参考《阿里巴巴Java开发手册(嵩山版)》的第一章节 “编程规约”。​
补充：

1.对返回结果的封装统一调用ResponseUtil.sucess()或ResponseUtil.Error()工具类。​
2.返回结果封装统一放在controller层，不能放在servcie层。​
1.2 代码规范插件安装​
通过Jetbrains官方仓库安装：​
1. 打开 Settings >> Plugins >> Browse repositories...​
2. 在搜索框输入alibaba即可看到Alibaba Java Code Guidelines插件，选择2.1.1版本，点击Install进
行安装，然后重启IDE生效。可在tool菜单栏内找到阿里编码规约菜单。​
1.3 代码规范插件使用​
目前插件实现了开发手册中的的53条规则，大部分基于PMD实现，其中有4条规则基于IDEA实
现，并且基于IDEA Inspection实现了实时检测功能。部分规则实现了Quick Fix功能，对于可以提供

Quick Fix但没有提供的，我们会尽快实现，也欢迎有兴趣的同学加入进来一起努力。 目前插件检测有
两种模式：实时检测、手动触发。
1. 实时检测
实时检测功能会在开发过程中对当前文件进行检测，并以高亮的形式提示出来，同时也可以支持
Quick Fix，该功能默认开启，可以通过配置关闭。​
2. 结果高亮提示
检测结果高亮提示，并且鼠标放上去会弹出提示信息。
Alt+Enter键可呼出Intention菜单，不同的规则会提示不同信息的Quick Fix按钮。​
3. 关闭实时检测
在某些情况下，我们不希望对代码提示违规信息，比如我们在阅读Github开源项目代码的时候，
如果界面出现一堆红色、黄色的提示，此时心里肯定是飘过一万只草泥马。这个时候我们可以通过
Inspection的设置关闭实时检测功能。​

•
通过右键快速关闭（打开）所有规则的实时检测功能
•
通过Settings >> Editor >> Inspections 进行手动设置，也可以关闭某条规则的实时检测功能或者修
改提示级别。
4. 代码扫描
可以通过右键菜单、Toolbar按钮、快捷键三种方式手动触发代码检测。同时结果面板中可以对部
分实现了QuickFix功能的规则进行快速修复。​
5. 触发扫描

在当前编辑的文件中点击右键，可以在弹出的菜单中触发对该文件的检测。
在左侧的Project目录树种点击右键，可以触发对整个工程或者选择的某个目录、文件进行检测。​

如果打开了IDE的Toolbar，也可以通过Toolbar中的按钮来触发检测，目前Toolbar的按钮触发的
检测范围与IDE当时的焦点有关，如当前编辑的文件或者是Project目录树选中的项，是不是感觉与右
键菜单的检测范围类似呢。
使用快捷键（Ctrl+Shift+Alt+J）触发弹出窗口，选择
检测范围；可自定义快捷键。​

6. 扫描结果
检测结果直接使用IDEA Run Inspection By Name功能的结果界面，插件的检测结果分级为
Blocker、Critical、Major。默认按等级分组，方便统计每个级别错误的数量。​
默认情况会在结果面板需要双击具体违规项才能打开对应的源文件，开启Autoscroll To Source选
项，单击面板中的文件名、或者是具体的违规项的时候IDEA会自动打开对应的源文件。​
7. QuickFix​
对于实现Quick Fix的规则，在结果面板中可以直接一键修复 注意：IDEA14、15可以通过左下角的
灯泡进行一键修复操作。

2. 日志规范​
2.1 日志分类规范​
日志文件按应用需求功能分为访问日志、应用日志和系统日志。按等级从低到高分为TRACE级、
DEBUG级、INFO级、WARN级、ERROR级、FATAL级六级。​
a. TRACE级、DEBUG级：理论上“不属于错误”，只是打印一些状态、提示信息，以便开发过程
中观察，开发完成、正式上线后需要屏蔽。
b. INFO级： 理论上“不属于错误”，只是一些提示性的信息，但是即使在开发完成、正式上线的
系统中，也有保留的价值。在实际环境中，系统管理员或者高级用户要能理解INFO输出的信息
并能很快的了解应用正在做什么。比如，一个和处理机票预订的系统，对每一张票要有且只有
一条INFO信息描述 "[Who] booked ticket from [Where] to [Where]"。​
c. WARN级：属于轻微的“警告”，程序中出现了一些异常情况，但是影响不大，还可以正常使
用。
d. ERROR级：属于“普通的错误”，在程序可以控制的范围内，不会造成连锁影响或巨大影响，
日志发生之后其实不会导致系统运行出现异常的，可能是对某些数据的初始化深入验证出现的
问题。​
e. FATAL级：属于“致命错误”，开发过程中的try...catch模块中抛出的一些未能预料到的系统错
误，可导致整个系统或者一系列功能无法使用，甚至导致系统瘫痪、关闭，必须马上有人进行
处理。比如：空指针异常，数据库不可用，如硬盘空间满等，关键业务流程中断等 等。​
2.2 日志输出规范​
示例：
error错误日志：
log.error("查询合同信息列表出错！错误信息：{}", e.getMessage(), e);​
info提示日志：​

log.info("开始远程调用erp附件删除接口，请求地址：{},请求头：{},请求入参：{}",callUrl,headersMap,docId);​
importorg.slf4j.Logger;​
importorg.slf4j.LoggerFactory;​
private static final Loggerlogger=LoggerFactory.getLogger(Abc.class);​
1.【强制】系统应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框
架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 ​
importlombok.extern.slf4j.Slf4j;​
@Slf4j​
public classAlipayService{};​
或者：
2.【强制】日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。​
3.【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：
appName\_logType\_logName.log。​
•
logType:日志类型，推荐分类有stats/desc/monitor/visit等；​
•
logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，
什么目的，也有利于归类查找。
正例：mppserver应用中单独监控时区转换异常，如：
mppserver\_monitor\_timeZoneConvert.log。 ​
说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通
过日志对系统进行及时监控。
4.【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。​
说明：logger.debug("Processing trade with id: " + id + " symbol: " + symbol); 如果日志级别是
warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方
法，浪费了系统资源，执行了上述操作，最
if (logger.isDebugEnabled()) {​
logger.debug("Processing trade with id: " + id + " symbol: " + symbol);​
};终日志却没有打印。 正例：（条件） ​
logger.debug("Processing trade with id: {} symbol : {} ", id, symbol);​

正例：（占位符） ​
解释：debug/info级别的信息，信息本身需要计算或合并的，必须加 isXxxEnabled() 判断在前，
这样可以大大提高高并发下的效率。如果不加 isXxxEnabled() 判断，"Processing trade with id: " +
id + " symbol: " + symbol在info级别下也会执行。​
<logger name="com.abc.efg" additivity="false">​
5.【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。​
logger.error(各类参数或者对象toString+ "\_" +e.getMessage(), e);​
6.【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关
键字throws往上抛出。 ​
7.【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用
warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记
得及时删除这些观察日志。 ​
说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思
考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ ​
8.【建议】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适
从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不
要在此场景打出error级别。 ​
以上8条来自于《阿里巴巴开发手册》---日志规约。​
9.【强制】应用程序禁止使用JDK Console输出(System.out, System.err, ex.printStackTrace(),
etc.)，应使用logger.debug、logger.error。所有的日志实例的属性都应从根日志（root logger）继
承。日志信息必须支持输出到控制台（console）和文本文件（TextFiles）。​
10.【强制】日志文件名必须满足<日志名>.log.yyyyMMddHH的命名规则。yyyyMMddHH表示每
日整点时重新命名日志文件，以方便按时间定位日志信息；单个日志文件建议50M~~100M之间，即当
日志文件超过该范围时，旧日志文件重命名为<日志名>.log.yyyyMMddHH.n(n从1开始编号以步长1递
增)，新日志写入<日志名>.log.yyyyMMddHH。这里的<日志名>可参考第三条规范。 ​
log.debug("Processing request with id: {}",request.getId());​

11.【强制】Log的内容须确保不会因为Log语句的问题而抛出异常造成中断，如下有可能会抛出
NullPointerException：​
12.【强制】日志保密机制。对于“敏感”的单位信息，如身份证、电话号码等信息，禁止使用
debug以上级别的日志方法记录，在开发过程中，也应减少日志对该类信息的记录。一些敏感信息可
以打马赛克后输出，比如字符串部分内容换成\*。如：身份证号422927194910011234,可以考虑这样输
出: 42292719491\*\*\*\*\*34。对于特别敏感的交易信息（如密码），不能输出到日志文件。输出到磁盘
或数据库上的log日志应注意保密。​
13.【强制】Log对象的声明和初始化，仅以下代码是符合规范：​
private static final Loggerlogger=LoggerFactory.getLogger(Xxx.class);​
private final Loggerlogger=LoggerFactory.getLogger(getClass());​
private static Loggerlogger=LoggerFactory.getLogger(Xxx.class);​
protected final Loggerlogger=LoggerFactory.getLogger(getClass());​
private Loggerlogger=LoggerFactory.getLogger(getClass());​
protected Loggerlogger=LoggerFactory.getLogger(getClass());​
private static final Loggerlogger=LoggerFactory.getLogger("loggerName");​
@Slf4j;​
public classXxxService{​
}​
或者
14.【建议】推荐在每个接口中，在其入口输出调用类名及输入参数的日志，以及接口结束前输出
返回数据的日志，并使用info级别。另外，重要方法入口，业务流程前后及处理的结果等，推荐记录
log，并使用debug级别，因为对于非开发人员掌控的环境（无法做DEBUG），记录方法调用、入参、
返回值的方式对于排查问题会有很大帮助。
15.【建议】关注日志记录对于系统性能、安全性的影响，不要多次重复记录日志。日志记录太过
于频繁，日志记录到文件IO或者数据库都是很费CPU和内存资源的事，会对系统的性能产生影响。关
注日志是否会被恶意攻击频繁打印日志，使得日志文件超过100G、500G直到磁盘容量爆满，服务器挂
掉。

16.【建议】记录要精简、不滥用日志，关注日志记录的正确性和必要性。分清楚什么时候应该记
录日志，什么时候不需要记录日志。什么是TRACE、DEBUG信息，什么是INFO、ERROR信息。对于
异常处理，不要多次重复的记录同一个异常的堆栈信息。比如在DAO层记录了异常堆栈信息，然后抛
出异常，在web层catch了异常之后，又记录了一次异常堆栈信息。 ​
17.【建议】在日志信息上添加便于检阅、查找的额外标识。每条日志都应有关键标识，能够尽快
定位某条信息的位置。包括日期和时间，程序Java类的名称、方法甚至行号，错误类型或者错误代
码。否则前端web页面报错，告诉开发人员去查找问题，开发人员很难去查找当时的操作日志或者异
常信息。
18.【建议】注意error和warn级别的区别，导致业务不正常服务的，用error级别；错误是预期会
发生的，并且已经有了其他的处理流程，使用warn级别。​
19.【建议】日志信息中尽量包含数据和描述：easy to read, easy to parse，开发人员不能为了自
己查找信息方便，输出类似“!@#$%”的Log。​
20.【建议】用户操作日志。用户操作日志面临记录频繁、数据结构异常多、数据流量非常大、数
据价值如何提高等问题。在记录用户的操作日志尽量不要浪费系统的额外性能开销。
21.【建议】系统审计日志。可参考记录以下内容：（1）权限管理日志；（2）帐号管理日志；
（3）系统自身日志（服务启停、故障等）；（4）用户登录日志；（5）服务接口调用日志；（6）业
务访问日志。
22.【建议】异常信息日志。当程序产生异常时，必须捕捉并处理异常、将异常记录到日志中（除
非打算抛出异常），捕获异常后不处理也不输出log是一种非常不负责任的行为，这会造成问题很难被
定位，极大地提高调试的成本。异常须注意以下几点：
(1)异常日志不要重复输出。​
(2)异常捕获尽量不要直接catch(Exceptionex)，应该把异常细分处理。​
(3)不要处理能够避免的异常。​
(4)记录异常不要保存exception.getMessage(),而要记录exception.toString()。。​
3. 异常规范​
3.1 错误码​

1. 【强制】错误码不体现版本信息，可以随着版本迭代，不断新增追加，应完全向下兼容。
2. 【强制】避免随意定义新的错误码，新的在原有错误码表中寻找语义相近的错误码。
3. 【强制】对于前端需要根据错误码来判断路由或者处理逻辑的，则需要重新定义错误码，前端得根
据错误提示信息处理业务逻辑。
4. 【强制】错误码不能直接输出给用户作为提示信息使用，错误码之外的业务独特信息由 msg 来承
载，而不是让错误码本身涵盖过多具体业务属性。
5. 【推荐】msg应该能支持国际化，便于产品适应不同的语言。​
3.2 异常处理​
1. 【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过catch
的方式来处理，比如： NullPointerException， IndexOutOfBoundsException 等等。​
2. 【强制】任何非平台自定义异常（例如IOException、SQLException等等），不得直接返回给控制
层，都需要重新包装成平台自定义异常（BusinessException）。​
3. 【强制】控制层不需要作异常捕获处理，所有异常均需须通过全局异常处理器
（GlobalExceptionHandler）转换成标准返回（ResponseBean）返回给前端。​
4. 【强制】禁止在前端直接显示异常原始信息或者堆栈信息。
5. 异常输出日志，log4j，返回异常配置国际化​
4. 安全规范​
a. 【强制】禁止任何明文形式的存储用户密码信息（包括数据库、缓存、日志、cookie等等）。​
b. 【强制】用户敏感数据禁止在前端直接展现，必需对敏感数据脱敏展现（比如身份证号、手机
号等等）。​
c. 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注
入，禁止字符串拼接 SQL 访问数据库。在mybatisplus使用时，禁止使用${}表达式。​
d. 【强制】 在使用系统资源，譬如短信、邮件、电话、等，必须实现正确的防重放或者限流机
制，如访问次数校验、验证码校验等，避免被滥刷而导致资源损失或者用户体验下降。​
e. 【强制】对敏感操作，如用户登录，重置密码等，需要记录日志并实现安全性校验。譬如限制
错误次数，冻结账户等。
f. 【强制】表单、 AJAX 提交必须执行 CSRF 安全验证。​
5. 事务规范​

a. 【强制】事务声明应该加在service实现层，禁止在controller层增加事务声明，建议加在
service接口上。​
b. 【强制】事务场景中，抛出异常被 catch 后，如果需要回滚，需要注意手动回滚事务。​
c. 【强制】@Transactional注解必需指定回滚的异常，也就是rollbackFor。​
d. 【强制】需要事务控制的方法，可见性必须声明为public。​
e. 【强制】 同一个类中的无事务控制方法调用有事务控制的方法时，需要重新注入本类，禁止通
过this.xxx方式调用。​
f. 【建议】查询类方法上，最好不要声明事务，节约系统资源。
第二章：设计规范
1. 数据库规范​
1.1 命名规范​
1.1.1 数据库名和表名命名规范​
序号​
命名规范​
范例​
1．​
数据库命名：PRO\_微服务名/基础
服务名缩写​
比如：工作流：PRO\_ACTIVITY​
2．​
表命名：微服务类型缩写+模块名
缩写+具体实体名​
(其中尽量用英文简写或者取单词​
前三个字母表示)​
1. 合同文本表：
PRO\_CONTRACT\_FILE
2. 合同模板参数表:：
PRO\_TEMPLET\_PARA​
3．​
临时表命名：表名必须以TMP +模
块名缩写+功能名 ​
TMP\_CONTRACT\_TERMS ​
4.​
历史表命名规则:HIS或者H，加上\_
日期​
HIS\_CONTRACT\_TERMS\_202212
06​
5.​
备份表命名规则:BAK或者B，加上\_
日期​
BAK\_CONTRACT\_TERMS\_202212
06​
1.1.2 字段命名规范​
序号​
命名规范​
范例​

1.
多个单词使用‘\_‘分隔​
例如：COMPANY\_CODE​
2.
字段必须填写描述信息​
例如：COMPANY\_CODE //单位编
码​
3.
禁止使用数据库关键字 ​
错误示例：NAME,TIME,DATETIME​
4.
采用字段的名称必须是易于理解，
一般不超过三个英文单词​
错误示例：​
预计总资本开支编辑
EST\_TOL\_EXP\_EDIT​
5.
大小写统一​
目前系统中保持的是小写统一​
错误示例：USER\_ID    HouseId​
修改
为”user\_id”，”house\_id”​
6.
名词​
尽量用简单明了的英文单词​
示例：​
用户id：USER\_ID   ​
 用户名称：USER\_NAME   ​
性别： SEX​
7.
动宾短语​
示例：IS\_FRIEND   IS\_GOOD​
8.
常用字段命名规范​
金额：如ADJUST\_AMT
DECIMAL(12,8) 调整后金额​
版本号：如VERSION\_NUMBER
INT 版本号​
编码：如COMPANY\_CODE
VARCHAR(50) 单位编码​
标识：如DELETE\_FALG
TINYINT(1) 逻辑删除标识​
页面输入备注：如REMARKS
VARCHAR(1000) 备注​
主键id，以表名含义，尽量不要直接取名id；如：用户表主键就叫user\_id​
1.1.3 索引命名规范​
序号​
命名规范​
范例​
1.
非唯一索引：IDX\_表名称缩写\_字
段名称缩写（不可超过30个字符）​
例如：PRO\_INVOICE\_BILL
表BILL\_ID字段：
IDX\_INVOICEBILL \_BILL​

2.
唯一索引：UNIQ\_表名称缩写\_字
段名称缩写（不可超过30个字符）​
例如：MRH\_DICT\_TYPE​
表DICT\_TYPE字段：UNIQ\_
DICT\_TYPE​
1.1.4 视图命名规范​
序号​
命名规范​
范例​
1.
UV\_专业类型缩写\_模块名缩写\_ 功
能标识 （不可超过30个字符）​
UV\_ PRO\_CONTRACTINFO​
1.2 设计规范​
1.2.1 表设计规范​
1. 【强制】表和列的名称尽量不要取的太长，表名不超过5个单词，列名不超过3个单词，表名只能使
用字母、数字和下划线，禁止拼音英文混合使用。尽量不要用缩写，单词全意。
2. 【强制】相关模块的表名与表名之间尽量体现join的关系，如user表和user\_role表。​
3. 【强制】 创建表时不需指定字符集和存储引擎（统一在建库时指定），但必须要有comment信
息。
4. 【强制】强制要求所有表都需要有物理主键为id，类型为 bigint，具备业务含义的字段不要设为主
键，如contract\_code等，可建立unique key索引。因为如果设为主键且主键值为随机插入，则会
导致innodb内部page分裂和大量随机I/O，性能下降。​
5. 【强制】每张表创建时包含如下审计字段：
 tenant\_id varchar(64) DEFAULT NULL COMMENT '租户id',​
`create\_by` varchar(64) DEFAULT NULL COMMENT '创建人',​
`create\_time` datetime DEFAULT NULL COMMENT '创建时间',​
`update\_by` varchar(64) DEFAULT NULL COMMENT '最后更新者',​
`update\_time` datetime DEFAULT NULL COMMENT '最后更新时间',​
`company\_code` varchar(64) DEFAULT NULL COMMENT '公司编码',​
 `CREATED\_DEPT` varchar(64) DEFAULT NULL COMMENT '部门编码',​
 `sys\_code` varchar(64) DEFAULT NULL COMMENT '系统编码',​
6. 【建议】尽量不使用TEXT(TINYTEXT、MEDIUMTEXT、LONGTEXT)，BLOB（TINYBLOB、
MEDIUMBLOB 、LONGBLOB）等大字段，因为读取大字段到内存浪费内存空间，影响系统性能。​
7. 【建议】保持一定的冗余设计：把经常需要join查询的字段，在其他表里冗余一份。如user\_name
属性可在uc\_login\_account，uc\_login\_history等表里冗余一份，减少join查询。​ ​

1.2.2 字段设计规范​
1. 【强制】意义相同的字段，如user\_id，设计时保证各表中字段类型、长度、排序集均一致，否则
join时无法使用索引。​
2. 【强制】不使用enum，set。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用
tinyint。​
3. 【强制】业务中选择性很少的状态status、类型type等字段使用tinytint类型节省存储空间。​
4. 【强制】存储金额相关字段，用DECIMAL代替FLOAT和DOUBLE存储精确浮点数。​
5. 【强制】文本数据用varchar存储，字符数不要超过2000。​
6. 【建议】业务中IP地址字段推荐使用unsigned int类型，不推荐用char(15)。因为int只占4字节，
而char(15)占用至少15字节。​
1.2.3 索引设计规范​
1. 【强制】InnoDB存储引擎表，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者
BTREE类型索引。​
2. 【强制】在建立索引时，多考虑建立联合索引，并把选择率最高的字段放在最前面。
3. 【强制】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在联
合索引key(a,b)，则索引key(a)为冗余索引，需要删除。​
4. 【强制】不要在索引字段进行数学运算和函数运算，会导致索引失效。
5. 【建议】合理使用覆盖索引，减少磁盘IO；如：select code,name from tab where code=’xxx’;
若code不是主键，可建立覆盖索引idx\_code\_name(code,name)。​
6. 【建议】单个表上的索引个数不能超过7个，组合索引字段数不超过5个。​
7. 【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。​
1.2.4 数据类型规范​
数据类型​
数据库字段类型​
整型数字​
INT​
长整型数字​
BIGINT​
变长短文本字符串​
VARCHAR​
变长大文本字符串​
LONGTEXT​

二进制文本​
BLOB​
二进制大文本​
LOGNGBLOB​
金额类数据​
DECIMAL​
时间​
DATETIME​
1.3 SQL语句规范​
1.3.1 书写风格​
1、语句关键字应全部使用小写。​
2. 引用字符时应使用单引号。如：update testable set idcol=’abcd’。​
3. 连接符或运算符or、in、and、＝、<=、>=， +，- 等前后宜加上一个空格。否则容易导致以下类似
问题。例如在语句select a–b from table中，a，b均为变量，拼写该语句时，如果a = 6，b = -3，则语
句变为select 6--3 from table。--被视为SQL的注释，结果语句报错。​
4. 不得使用“select \* from …”语法，必须标明字段名。即select col1, col2,… from tablea where …​
5. 严禁使用“insert into table\_name values (?,?,……)”语法，统一使用“insert into table\_name
(col1,col2,……) values (?,?,…...)”。​
6. SQL语句包含多表连接时，必须加上表的别名，对每个字段的使用都要带上表别名。即 select
a.col1, a.col2, b.col3 from tablea a, tableb b where a.col4=b.col5,字段取别名时，使用as关键字，不
要使用空格
7. 应避免显式或隐含的类型转换。例如在where子句中numeric型和int型的列的比较。​
8. 在子查询中前后必须加上括号。select col1, col2 from tablea where col3 in ( select col4 from
tableb where col4>0)​
9. 执行SQL时一次应只执行一条，如果多条语句则应分开执行，但必须保持在一个事务中。不得一次
执行通过分号等分开的多条语句，这样处理不清晰。
10. 如果能采用or代替，则不宜使用in 语句。in语句中的元素不得超过500个，如果超过，则应拆分为
多条SQL语句。严禁使用xx in(‘’,’’….) or xx in(‘’,’’,’’)。​
11. or连接条件不得超过 500，超过时应拆分为多条语句。​
1.3.2 性能优化​
1. 查询时应尽量减少多余数据的读取，通过使用where子句来减少返回的记录数。​
2. 如果在语句中有not in（in）操作，应尽量用not exists（exists）来代替。特别对大数据量的两者检
索速度有很明显的区别。
3. 不宜使用外连接。外连接效率低。​

4. 一条SQL语句中不宜使用3层以上的嵌套查询。如果超过，则应在Java等应用服务器程序中处理。​
5. 一条SQL语句中不得从4个及以上表中同时取数。仅作关联或过滤条件而不涉及取数的表不参与表个
数计算；如果必须关联4个或4个以上表，应在Java等应用服务器程序中处理。​
6. 应尽量避免使用order by和group by排序操作，如必须使用排序操作，尽量建立在有索引的列上。
因为大量的排序操作影响系统性能。
7. 对索引列的比较，应尽量避免使用not 或 !=，可拆分为几个条件。因为“not”和“!=”不会使用索
引。如col1 是索引列，条件col1 !=0 可以拆分为col1 >0 or col2 <0。​
8. 应尽量将数据库函数、计算表达式写在逻辑操作符右边。因为这些对列的操作会将导致表扫描，影
响性能。
9. 在where子句中，如果有多个过滤条件，应将索引列或过滤记录数最多的条件放在前面。​
10. 能用连接方式实现的功能，不得用子查询。例如：select name from customer where
customerId in ( select customerId from order where money > 1000)。 应该用如下语句代替：
select name from customer inner join order on customer.customerId = order.customerId where
order.money > 100。或 select name from customer where exists ( select 1 from order where
money > 1000 and customer.customerId = order.customerId) <这里需要注意：使用exists的效率依
赖于匹配度，inner join效率比较稳定>​
11. 多表关联查询时，写法可遵循以下原则，这样做有利于建立索引，提高查询效率。格式如下：
select sum (t1.je) from table1 t1, table2 t2, table3 t3 where (t1的等值条件（=）) and (t1的非等值
条件) and (t2与t1的关联条件) and (t2的等值条件) and (t2的非等值条件) and (t3与t2的关联条件) and
(t3的等值条件) and (t3的非等值条件)。​
1.3.3 跨数据库支持​
1. 对于跨数据库Java应用程序的VO映射数据库的数据格式建议：​
1) 整型字段：字段设置保存为Integer或者Long​
2) 数字型字段：若需要使用小数2位以上的精确计算，读取、插入、更新使用BigDecimal类型​
3) 字符型字段：读取为String，并保存为String，插入或者更新为String​
4) 时间字段：读取为String，插入或者更新时的时间格式使用中间件统一处理。​
2. 字符串连接应使用“||”符号，而不应使用“+”。“+”是SQLServer语法，Oracle和DB2支
持“||”，Hibernate转化为SQLServer时，会自动将“||”转为“+”。​
3. 通配符不能使用‘[a-c]%’这种形式。应写成如：select col1, col2 from table\_name where col1
like ‘[a]%’ OR col1 like ‘[b]%’ OR col1 like ‘[c]%’​
4. 截取字符串长度函数应使用substr，起始位置为1表示从头开始。因为db2中substr起点为1，0会报
错；在SqlServer数据库中使用的是substring需要进行转换。​
5. 不得通过select percent n和select top n限制查询结果集的记录数。
6. join 与on 必须严格匹配，严禁出现没有on的join。​

7. join…on 后面不宜使用or，如果使用则需将or的范围用( )括起来。​
8. 不得使用select into 的格式。Select into是SQL Server特有语法，因为Oracle和DB2不支持。​
9. 应将Null值与空字符串(长度为零的字符串)视为不同。虽然Oracle视Null与空字符串为相同，但DB2
和SQL Server却视为不同。​
2．类名规范​
2.1 类名与接口名​
序号​
命名规范​
范例​
1.
微服务类型缩写+模块名缩写+具体
类名​
(其中尽量用英文简写或者取单词前
三个字母表示)​
合同文件服务实现类
ContractFileServiceImpl​
2.
以大写字母开头，如果有多个单
词，每个单词首字母大写​
例如：StudentInfo​
3.
接口命名：以大写字母”I”开头，
如果有多个单词，每个单词首字母
大写​
例如：IStudentInfo​
4.
接口实现类命名：将实现的接口名
称的首字母”I”去掉，
以”Impl”作为结尾，如果有多个
单词，每个单词首字母大写​
例如：StudentInfoImpl​
2.2 类变量命名规范​
序号​
命名规范​
范例​
1.
变量名首字母必须小写，如果变量
名有多个单词组成，后面的单词首
字母大写，单词与单词之间不能使
用“\_”连接，变量名访问控制必
须为私有，可以对其增加get与set
方法​
合同ID：private String contractId​
合同名称：private String
contractName​
2.3类常量命名规范​

序号​
命名规范​
范例​
1.
常量名全部大写,多个单词中间用下
划线连接​
例如：​
public static final String
GAME\_COLOR=”RED”;​
2.4类方法命名规范​
序号​
命名规范​
范例​
1.
方法名首字母小写，如果名称由多
个单词组成，每个单词的首字母都
要大写，第一个单词为动词。​
增删改查的业务接口以下面名称开
头：​
查询：selectXXXX​
新增：saveXXXX​
修改：updateXXXX​
删除：deleteXXXX​
例如：​
public void toString(){}​
2.5命名公共规范​
•
名称只能由字母、数字、下划线、$符号组成​
•
不能以数字开头
•
名称不能使用JAVA中的关键字​
•
坚决不允许出现中文及拼音命名
3．数据对象设计规范​
3.1数据对象命名规范​
序号​
数据对象名称​
实体命名规范​
1.​
视图对象​
VO后缀，展示对象，用于展示层，
作用是把某个指定页面（或组件）
的所有数据封装起来。​

2.​
业务对象​
BO后缀，业务对象，把业务逻辑封
装为一个对象，这个对象可以包括
一个或多个其它的对象​
3.​
持久化对象​
PO或者Entity后缀，持久化对象，
跟持久层（通常是关系型数据库）
的数据结构形成一一对应的映射关
系，如果持久层是关系型数据库，
那么，数据表中的每个字段就对应
PO的一个属性​
4.​
数据传输对象​
DTO后缀，展示层与服务层之间传
递数据的对象，VO一般是通过DTO
转换而来，比如用户DTO里包含密
码字段，但是返回给展示层就需要
将密码字段擦除。​
3.2数据对象设计规范​
1. 【强制】单一职责原则，不同数据对象只能在相应层中使用，禁止不同层中复用相同的数据对象。
比如，PO只能在持久层使用，BO在业务层。​
2. 【强制】PO类的属性必需和相应数据库表字段一一对应。​
3. 【建议】VO不是必选项，大多数情况下，使用DTO即可完成任务，但命名规范可以用VO（此时VO
就是DTO）。​
4．REST接口设计规范​
4.1 URI格式规范​
序号​
命名规范​
范例​
1.
"/"分隔符一般用来对资源层级的划
分​
例如：​
http://api.canvas.restapi.org/sha
pes/polygons/quadrilaterals/squ
ares​
2.
例如：​

尽量使用连字符"-"代替下划
线"\_"的使用，提高URI的可读性​
http://api.example.restapi.org/bl
ogs/mark-masse/entries/this-is-
my-first-post​
3.
统一使用小写字母​
URI是对大小写敏感的，所以为了
避免歧义，我们尽量用小写字符​
4.
不要包含文件(脚本)的扩展名​
例如：php .json 之类的就不要出
现了，对于接口来说没有任何实际
的意义。如果是想对返回的数据内
容格式标示的话，通过HTTP
Header中的Content-Type字段更
好一些​
4.2 返回的状态码和提示信息​
•
200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。​
•
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。​
•
202 Accepted - [\*]：表示一个请求已经进入后台排队（异步任务）​
•
204 NO CONTENT - [DELETE]：用户删除数据成功。​
•
400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修
改数据的操作，该操作是幂等的。
•
401 Unauthorized - [\*]：表示用户没有权限（令牌、用户名、密码错误）。​
•
403 Forbidden - [\*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。​
•
404 NOT FOUND - [\*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是
幂等的。
•
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格
式）。
•
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。​
•
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。​
•
500 INTERNAL SERVER ERROR - [\*]：服务器发生错误，用户将无法判断发出的请求是否成功。​
•
502 网关错误​
•
503 Service Unavailable​
•
504 网关超时​ 一​

4.3 统一返回结果规范​
参数名​
类型​
必需​
描述​
code​
String​
是​
返回状态码​
msg​
String​
是​
返回信息​
data​
T​
是​
返回结果​
4.4 接口规范制定规则​
1. 文件格式：word文档格式保存为.docx格式，避免对接集成平台出现兼容性问题。​
2. 服务版本号：都是0.1保持不变​
3. 数据类型：只支持“VARHCAR2”、“NUMBER”、“DATE”、“数据实体”、“CLOB”，
VARCHAR2型需标明长度，当VARCHAR2的长度超过4000时，数据类型为CLOB。​
4. 定时/实时：定时和实时集成平台默认是互斥的，看主要业务需求。涉及定时同步的接口，就定义
为定时。
5. 输入：
6. MsgHeader:​
（固定格式）2个预留字段，名称：RESERVED\_1，类型：VARCHAR2(50)，预留字段1……​
7. 查询条件:​
QUERY\_EXT，LAST\_UPDATE\_START，LAST\_UPDATE\_END三个字段为预留字段必须保留; 查询
条件中两个备用字段，名称：RESERVED\_1，类型：VARCHAR2（240） 预留字段1……​
8. 输出：
9. 预留OUTPUT\_EXT字段，主要用于后续输出结果的灵活扩展。该字段内容为Json格式长字符串。
查询结果输出的每个数据对象（包括主对象和子对象）中都需要预留OUTPUT\_EXT字段。对于MFT
服务不做强制要求。
10. 返回查询结果中没有必填/非必填列​
在InputCollection、outputCollection、数据实体中增加5个备用字段，名称：ATTRIBUTE1，类型：
VARCHAR2（240）备用字段1......​
11. 如对于OUTPUT\_EXT扩展字段，Json内容参考为​
{​
 "OUTPUT\_EXT": {​
   "OrderNo": "ES00000001",​

   "OrderName": "采购订单",​
   "Address": "北航致真大厦",​
   "StoreName": "1号仓库"​
 }​
}​
其中第一层为OUTPUT\_EXT扩展字段名​
5．其它规范​
5.1数据字典字典编码(DIC\_TYPE)命名​
序号​
命名规范​
范例​
5.
pro\_模块名缩写+具体数据类型​
例如：​
合同签约主体角色：​
pro\_contract\_sign\_role​
第三章：代码版本规范
1.2 分支管理​
1.2.1 master 主分支​
说明：master主分支始终保持稳定的可发布版本​
规范：禁止直接在master分支上直接开发，且只允许开发经理拥有master分支的管理权限（例如
其他分支合并到master等）。master分支代码与当前发行版本代码始终保持一致。​
1.2.2 dev 开发分支​
说明：dev开发分支为不稳定版本，可能存在功能缺失，但已有的功能必须是完整的。​
规范：原则上不允许直接在dev分支上进行功能开发，必须新建feature分支进行开发。​
1.2.3 hotfix-[bug编号] 紧急热修复分支​
说明：主要用于对已上线版本的紧急bug修复。​

规范：从master分支创建，横线后面跟上问题名称或者对应的bug编号。修复完成，测试通过，
合并到master和dev分支上，然后将此分支删除。​
1.2.4 feature-[任务编号] 功能开发分支：​
说明：从dev分支创建，横线后跟任务编号，用于新功能开发，每天下班前push提交到远程。
（在1.0版本前，可以按照开发人员来新建分支，在功能上线或者定版后，必需按照特性新建分支）。​
规范：开发完成以后，在远程发起向dev分支的合并请求，由指定的CodeReview人员审查通过以
后进行合并，在任务所属迭代完成（上线）后删除该分支。
1.2.5 bugfix-[bug编号] 问题修复分支：​
说明：从dev分支创建，用于修改测试提出的bug，横线后跟bug编号​
规范：修复以后，在远程发起向dev分支的合并请求，并指定提交者自身（或其他人）作为
CodeReview，bug确定修复以后可以删除该分支。如果在当前迭代内，feature分支还未删除时，也可
在相应feature分支上进行bug修复。​
1.2.6 refactor-[重构名称] 重构分支：​
说明：从dev分支创建，用于代码的重大规模重构（小规模重构创建feature分支即可）​
规范：重构以后，必须经过严格测试通过，才能向dev分支合并。。​
1.3 操作规范​
1.3.1 提交信息格式​
模板：[type][模块名称]……(具体的描述)​
示例：[feat][合同拟定]实现新增接口逻辑​
Type 的类别说明：​
•
feat: 添加新特性​
•
fix: 修复 bug​
•
docs: 仅仅修改了文档​
•
style: 仅仅修改了空格、格式缩进、typo 等等，不改变代码逻辑​

•
refactor: 代码重构，没有加新功能或者修复 bug​
•
perf: 增加代码进行性能测试​
•
test: 增加测试用例​
•
chore: 改变构建流程、或者增加依赖库、工具等​
1.3.2 提交频率​
•
每天下班前必须提交分支，并push到远程。​
•
hotfix、feature、bugfix、refactor分支尽量按照功能点或修复重构的问题及时commit（不要求
push）​
1.3.3 操作规范​
1.4 注意事项​
1.4.1 代码review​
重要功能的代码合并需要进行codereview。由于目前开发人员均有merge权限，故不需要在git上
提merge request，但开发经理需要组织代码review，或者结对编程的开发人员对对方的代码进行检
查。 ​

1.4.2 合并冲突处理​
合并出现冲突，需要由冲突双方共同商议解决冲突，切忌想当然修改代码解决问题。